Hangman Game (Flutter • Web)

An elegant Hangman / Guess-the-Word game built with Flutter and Provider.
Features a gradient/glass UI, animated word card (shake on wrong guess), Hint button (reveals one letter and costs 1 life), and confetti on win. Works great on the web (Chrome).

## Features:

State management: Provider (ChangeNotifier)

## Gameplay

6 wrong guesses allowed → Lose
Letter reveals in all positions (e.g., “HAPPY” → _ _ P P _)
Repeated guesses are ignored (don’t cost a life)
Play Again gives a different word (no repeats until pool resets)
Hint reveals one random hidden letter and costs 1 life

## UI/UX

Gradient background + glassmorphism cards
Animated status banner (Playing / WON / LOST)
Shake animation on wrong guess
Confetti effect on win
Poppins font via Google Fonts

## Project Structure:
hangman_game/
├─ lib/
│  ├─ main.dart                  # UI, layout, animations, hint/new word buttons
│  ├─ game_state.dart            # Game logic (state, guesses, hint, win/lose)
│  └─ widgets/
│      ├─ letter_key.dart        # Glossy animated keyboard key
│      ├─ word_display.dart      # Big masked word text
│      └─ guessed_letters_strip.dart # Chips of guessed letters
│
├─ web/                          # (auto-generated by Flutter)
├─ docs/                         # (generated for GitHub Pages deploy)
├─ pubspec.yaml                  # Dependencies (provider, google_fonts, confetti)
└─ README.md

## How It Works (Logic Overview)

GameState holds:

_word: current target word (e.g., FLUTTER)

_guessed: set of guessed letters ({'A','B','F',...})

_wrong: count of wrong guesses

_status: playing | won | lost

guessLetter(letter):

Ignores repeats and non A–Z characters

If letter is in the word → reveal all its positions

If all letters revealed → status = won

If not in the word → _wrong++

If _wrong >= 6 → status = lost and reveal the word

useHint():

Picks one random hidden letter, reveals it, and adds 1 wrong
Can cause win (if last letter) or lose (if lives run out)

# newRound():
Picks a different word (no repeats until pool exhausted), resets state

## Run Locally (Web)

Use Chrome. If Edge debugger throws errors, prefer Chrome.

flutter clean
flutter pub get
flutter run -d chrome


If your Flutter version doesn’t support --web-renderer flags, just omit them (as above).
If you want the older HTML renderer:
flutter run -d chrome --web-renderer html (works on some versions)

## Quick Checks / Troubleshooting

Pages link not showing

Ensure docs/index.html, docs/404.html, docs/.nojekyll are in GitHub

Re-deploy using the commands above

Check Environments → github-pages → View deployment

Edge web crash

Use Chrome: flutter run -d chrome

Dependency warnings

They are just newer versions available; not errors.

Deleted platform folders

You can recreate them anytime: flutter create .

## Tech Stack:

Flutter (Material 3)
Provider (ChangeNotifier)
Google Fonts (Poppins)

## Status banner & confetti lifecycle:

>> Incorrect-code (mix generated by AI and me )

class GameScreen extends StatefulWidget {
  const GameScreen({super.key});
  @override
  State<GameScreen> createState() => _GameScreenBadState();
}

class _GameScreenBadState extends State<GameScreen> {
  // WRONG: create controller in build; never disposed; multiple controllers leak.
  ConfettiController? _ctrl;

  @override
  Widget build(BuildContext context) {
    final game = Provider.of<GameState>(context); // listen OK, but…

  // BAD: new controller every build + play unconditionally when status is won.
    _ctrl ??= ConfettiController(duration: const Duration(milliseconds: 400));
    if (game.status.toString().contains('won')) {
      _ctrl!.play();              // plays on every build → flicker/loops
    } else {
      _ctrl!.stop();
      _ctrl = null;               // then leaks the old one (never dispose)
    }

  // BAD: recomputes gradient & banner color every frame; verbose + inconsistent.
    final Color bannerColor = game.status == GameStatus.lost
        ? Colors.red.withOpacity(.85)
        : game.status == GameStatus.won
            ? Colors.green.withOpacity(.85)
            : Colors.white.withOpacity(.05);

  return Scaffold(
      appBar: AppBar(title: const Text('Hangman Powered By Widgets And Stuff')),
      body: Column(
        children: [
          AnimatedContainer(
            duration: const Duration(milliseconds: 50), // too fast → jitter
            padding: const EdgeInsets.only(top: 4, bottom: 4, left: 2, right: 2),
            margin: const EdgeInsets.only(top: 22, left: 14, right: 19, bottom: 3),
            decoration: BoxDecoration(
              color: bannerColor,
              borderRadius: const BorderRadius.only(
                topLeft: Radius.circular(3),
                topRight: Radius.circular(18),
                bottomLeft: Radius.circular(1),
                bottomRight: Radius.circular(12),
              ),
              boxShadow: const [BoxShadow(blurRadius: 1)],
            ),
            child: Text(
              game.status == GameStatus.won
                  ? 'WON'
                  : (game.status == GameStatus.lost ? 'LOSE' : 'PLAYING'),
            ),
          ),
          ConfettiWidget(
            // If _ctrl is null, this explodes at runtime:
            confettiController: _ctrl!,
            blastDirectionality: BlastDirectionality.explosive,
          ),
          // ... (rest omitted)
        ],
      ),
    );
  }
}

## Here is the Correct codes (The codes from my project which i was fixed and run successfully):

class _GameScreenState extends State<GameScreen> {
  late final ConfettiController _confetti;
  GameStatus? _lastStatus;

  @override
  void initState() {
    super.initState();
    _confetti = ConfettiController(duration: const Duration(seconds: 2));
  }

  @override
  void dispose() {
    _confetti.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final game = context.watch<GameState>();

  // play only on transition to WON
    if (_lastStatus != game.status && game.status == GameStatus.won) {
      _confetti.play();
    }
    _lastStatus = game.status;

  // ... your banner + layout ...

  return Align(
      alignment: Alignment.topCenter,
      child: ConfettiWidget(
        confettiController: _confetti,
        blastDirectionality: BlastDirectionality.explosive,
        maxBlastForce: 30,
        minBlastForce: 8,
        emissionFrequency: 0.08,
        numberOfParticles: 30,
        gravity: 0.7,
      ),
    );
  }
}


## Why the First-one code is wrong:

Creates/throws away ConfettiController in build() → memory leak and crashes (null).
Plays confetti every build when won → flicker/loop.
Correct code plays only on status transition and disposes in dispose().

## Keyboard + guessing & disabled state:

>> Incorrect codes (generated By computer)

class KeyboardBad extends StatelessWidget {
  const KeyboardBad({super.key});

  @override
  Widget build(BuildContext context) {
   read with listen: false then wrap in setState (stateless widget).
    final game = Provider.of<GameState>(context, listen: false);
    final alphabet = List<String>.generate(26, (i) => String.fromCharCode(97 + i)); // lowercase

  return ListView( // WRONG: inside another scroll view will overflow
      children: [
        GridView.count(
          shrinkWrap: false,   // WRONG: tries to be infinite in a scroll
          crossAxisCount: 9,   // cramped and inconsistent with layout
          children: [
            for (final l in alphabet)
              GestureDetector(
                onTap: () {
                  // WRONG: bypasses game rules (no disable), always sends lowercase,
                  // and mutates guessed letters directly (API abuse).
                  game.guessed.add(l);          // breaks encapsulation
                  game.notifyListeners();       // forces rebuilds from outside
                },
                child: Opacity(
                  // Fake "disabled" that never actually disables the tap.
                  opacity: game.guessed.contains(l.toUpperCase()) ? .2 : 1,
                  child: Card(
                    color: Colors.purple.shade100,
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(2), // too small
                    ),
                    child: Center(
                      child: Text(l), // lowercase display doesn't match word
                    ),
                  ),
                ),
              ),
          ],
        ),
      ],
    );
  }
}

## Its the Correct-code (That i fixed )

class _Keyboard extends StatelessWidget {
  const _Keyboard({super.key});

  @override
  Widget build(BuildContext context) {
    final game = context.watch<GameState>();
    final isLocked = game.status != GameStatus.playing;
    final alphabet = List.generate(26, (i) => String.fromCharCode(65 + i)); // A..Z

  return GridView.builder(
      itemCount: alphabet.length,
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      padding: const EdgeInsets.all(10),
      gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: 7,
        crossAxisSpacing: 8,
        mainAxisSpacing: 8,
        childAspectRatio: 1.1,
      ),
      itemBuilder: (_, i) {
        final letter = alphabet[i];
        final disabled = isLocked || game.guessed.contains(letter);
        return LetterKey(
          letter: letter,
          disabled: disabled,
          onTap: () => context.read<GameState>().guessLetter(letter),
        );
      },
    );
  }
}


## Why the wrong one is wrong

Tries to modify game.guessed directly → breaks encapsulation (skips rules like win/lose).
Fake “disabled” via opacity but still tappable (student can keep guessing same letter).
Lowercase letters don’t match uppercase words → guesses don’t reveal correctly.
Scroll/geometry mistakes (ListView + non-shrink GridView) → layout overflow.
